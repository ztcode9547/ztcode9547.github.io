<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Linux on 404_abandon</title>
        <link>https://ztcode9547.github.io/tags/linux/</link>
        <description>Recent content in Linux on 404_abandon</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>404_abandon</copyright>
        <lastBuildDate>Sat, 01 Jul 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://ztcode9547.github.io/tags/linux/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>socket编程</title>
        <link>https://ztcode9547.github.io/p/socket%E7%BC%96%E7%A8%8B/</link>
        <pubDate>Sat, 01 Jul 2023 00:00:00 +0000</pubDate>
        
        <guid>https://ztcode9547.github.io/p/socket%E7%BC%96%E7%A8%8B/</guid>
        <description>&lt;p&gt;网络通信：Socket+IO复用+多线程或者线程池+libevent框架&lt;/p&gt;
&lt;h1 id=&#34;基本概念&#34;&gt;基本概念
&lt;/h1&gt;&lt;h2 id=&#34;局域网&#34;&gt;局域网
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;覆盖范围较小的计算机网络，外面访问不到。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;广域网&#34;&gt;广域网
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;是一种覆盖广泛地理区域的计算机网络，它可以跨越城市、国家甚至跨越大陆。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;网络协议&#34;&gt;网络协议
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;是互相通信对等实体必须遵守的一种规则，这种规则可以是标准的，也可以说自定义的。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;ip协议&#34;&gt;IP协议
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;是表示终端在网络中的地址，分为IPv4和IPv6。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我们在window系统cmd下输入命令ipconfig或者在Linux系统下输入ifconfig都可以显示ip地址，这个ip地址是局域网内的ip地址，如果使用网线接入外网，会统一分配公网IP地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IPv4本质是一个整形数，有4个字节，所以有32位，所以有2的32次方个ip地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IPv4使用点分十进制来表示，比如192.168.247.135，最小为：0.0.0.0，最大为：255.255.255.255。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以使用ping+域名的方式查看当前设备是否能访问域名地址。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;端口&#34;&gt;端口
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ip地址是能够定位设备，端口是能够定位计算机里面的进程。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;端口本质是一个无符号的短整型，占两个字节，所以有0到65535种可能性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;tcpip四层模型&#34;&gt;Tcp/Ip四层模型
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://ztcode9547.github.io/p/socket%E7%BC%96%E7%A8%8B/Tcp_Ip%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B.png&#34;
	width=&#34;189&#34;
	height=&#34;514&#34;
	srcset=&#34;https://ztcode9547.github.io/p/socket%E7%BC%96%E7%A8%8B/Tcp_Ip%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B_hu1767345724923505170.png 480w, https://ztcode9547.github.io/p/socket%E7%BC%96%E7%A8%8B/Tcp_Ip%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B_hu4686904838196450558.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Tcp_Ip四层模型&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;36&#34;
		data-flex-basis=&#34;88px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;应用层：最上层，也是程序员写业务的层次。有HTTP（超文本传输协议），FTP（文件传输协议）&lt;/p&gt;
&lt;p&gt;传输层：TCP协议，UDP协议&lt;/p&gt;
&lt;p&gt;网络层：IP协议&lt;/p&gt;
&lt;p&gt;网络接口层：无线局域网（WLAN），以太网（Ethernet）&lt;/p&gt;
&lt;h2 id=&#34;字节序&#34;&gt;字节序
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;顾名思义是字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序，也就是说对于单字符来说是没有字节序问题的，字符串是单字符的集合，因此字符串也没有字节序问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;目前字节序有两种：小端字节序（主机字节序）和大端字节序（网络字节序）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;小端字节序（主机字节序）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据的地位存储到内存的地位，数据的高位存储到内存的高位。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;我们使用的PC机，数据的存储默认使用的是小端。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;大端字节序（网络字节序）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据的地位存储内存的高位，数据的高位存储内存的地位。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;套接字通信过程中操作的数据都是大端存储的，包括：接收/发送的数据、IP地址、端口。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;字节序在编程中一般在ip地址和端口绑定需要手动转换，而在发送数据和接收数据的函数里，系统内核自动帮我们进行字节序的转换&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;总结:我们使用的设备是用主机字节序的，而网络通信是使用网络字节序的，所以我们要把数据转为网络字节序进行通信，通信结束，然后又把网络字节序转为主机字节序进行接收。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字节序举例：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://ztcode9547.github.io/p/socket%E7%BC%96%E7%A8%8B/%E5%AD%97%E8%8A%82%E5%BA%8F%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E4%B8%BE%E4%BE%8B.png&#34;
	width=&#34;444&#34;
	height=&#34;150&#34;
	srcset=&#34;https://ztcode9547.github.io/p/socket%E7%BC%96%E7%A8%8B/%E5%AD%97%E8%8A%82%E5%BA%8F%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E4%B8%BE%E4%BE%8B_hu15231814666717699858.png 480w, https://ztcode9547.github.io/p/socket%E7%BC%96%E7%A8%8B/%E5%AD%97%E8%8A%82%E5%BA%8F%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E4%B8%BE%E4%BE%8B_hu96969010991770678.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;字节序的存储方式举例&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;296&#34;
		data-flex-basis=&#34;710px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;socket网络通信&#34;&gt;Socket网络通信
&lt;/h2&gt;&lt;p&gt;​	就像一台排插，排插就是服务器，插头就是客户端，排插有多个插口，等待多个插头链接。和套接字相关的函数被包含在头文件&lt;strong&gt;sys/socket.h&lt;/strong&gt;中。&lt;/p&gt;
&lt;h2 id=&#34;tcp通信流程&#34;&gt;TCP通信流程
&lt;/h2&gt;&lt;p&gt;TCP三大特点：面向连接，安全，流式传输&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;面向连接：是一个全双工的通信，三次握手建立连接，四次挥手解除链接。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安全：会对每一个包进行校验，丢包会重发。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;流式传输：相当于发送接收两端有一条水管，发送多了，接收不了那么多，会让发送慢点。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ztcode9547.github.io/p/socket%E7%BC%96%E7%A8%8B/TCP%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B.png&#34;
	width=&#34;445&#34;
	height=&#34;631&#34;
	srcset=&#34;https://ztcode9547.github.io/p/socket%E7%BC%96%E7%A8%8B/TCP%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B_hu9196714618122811001.png 480w, https://ztcode9547.github.io/p/socket%E7%BC%96%E7%A8%8B/TCP%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B_hu1595196316029287531.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;TCP通信流程&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;70&#34;
		data-flex-basis=&#34;169px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;文件描述符在网络通信中的作用&#34;&gt;文件描述符在网络通信中的作用
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一个文件描述符对应两个内存。一个叫读缓冲区，一个叫写缓冲区。我们在调用accept函数，send函数和wirte函数时，客户端和服务器不是直接发送的，而是通过这些函数往这些缓冲区写数据或者读数据，然后内核会帮我们从缓冲区里面拿数据进行网络通信，是操作系统自动的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个文件描述符对应两个内存：一个叫读缓冲区，一个叫写缓冲区。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;读缓冲区：通过文件描述符可以把内存的数据读出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;写缓冲区：通过文件描述符可以往内存写入数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;监听类型的文件描述符：也包含两块内存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用accpet函数会监听这个文件描述符的读缓冲区，如果没有连接请求，这个读缓冲区为空，则会阻塞。这也是调用accept函数会阻塞的原因。&lt;/li&gt;
&lt;li&gt;如果不为空，则可以往读缓冲区内存读数据，则解除阻塞。说明有新的客户端连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通信的文件描述符:也包含两块内存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;和上面类似，调用的send函数和wirte函数都是监听内存是否有数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结：&lt;strong&gt;通过这种方式，可以增加网络通信的安全性，程序员不必管数据是如何发送和接收的，只要把数据放入相应的缓冲区和读取相关的缓冲区即可。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;通信代码&#34;&gt;通信代码
&lt;/h1&gt;&lt;h2 id=&#34;基于tcp的服务器端通信代码&#34;&gt;基于Tcp的服务器端通信代码
&lt;/h2&gt;&lt;h2 id=&#34;基于tcp的客户器端通信代码&#34;&gt;基于Tcp的客户器端通信代码
&lt;/h2&gt;</description>
        </item>
        
    </channel>
</rss>
